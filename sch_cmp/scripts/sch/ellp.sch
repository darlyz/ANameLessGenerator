DEFI
STIF s
LOAD f
TYPE e
MDTY l
INIT 1

COEF u1

EQUATION
\ === 定义向量 ===
VECT u1,du,gu
\ === 从unod中读取u1(上一迭代步的结果)，du(上一迭代步的增量)，gu(上一增量步的全量结果) ===
READ(s,unod) u1,du,gu
\ ================================================================
\ =    L(U(n+1) - U(n)) + F = 0                                  =
\ =--------------------------------------------------------------=
\ =    -(L(U(n+1) - U(n));u) = (F;u)                             =
\ =    S(U(n))*U(n+1) = F + S(U(n))*U(n)                         =
\ ================================================================
\ ==== 按照上面的形式，MATRIX为方程组左端项FORC为方程组右端项 ===
MATRIX = [s]
\ === FORC为方程组右端项 ===
FORC=[f]+[s*u1]

SOLUTION u
VECT u1,u,ue,du,gu
\ === 从unod中读取u1(上一迭代步的结果)，du(上一迭代步的增量)，gu(上一增量步的全量结果) ===
READ(s,unod) u1,du,gu
[ue]=[u]-[u1]
$CC aa = 0.0;
$CC ab = 0.0;
$CC bb = 0.0;
$CC // ===============================================================
$CC // =    对所有节点(NOD)和自由度(DOF)循环                         =
$CC // =-------------------------------------------------------------=
$CC // =    aa：当前迭代步增量ue的模的平方的和                       =
$CC // =    ab：当前迭代步增量ue与上一迭代步增量du内积的和           =
$CC // =    bb：上一迭代步增量du的模的平方的和                       =
$CC // ===============================================================
%NOD
%DOF
 aa = aa+[ue]*[ue];
 ab = ab+[ue]*[du];
 bb = bb+[du]*[du];
%DOF
%NOD
#sum double aa ab bb
$CC err = aa;                         // err 为当前迭代步误差
$CC if (itn==1) cc = 1.0;             // 迭代第一步取松弛因子为 1
$CC if (itn>1) {                      // 下面每一迭代步都调整松弛因子
$CC rab = sqrt(aa)*sqrt(bb);          // 当前增量UE与上一增量DU模乘积
$CC if (ab>0.5*rab) cc = cc*2.0;      // 若UE与DU夹角小于60°，松弛因子增倍
$CC if (ab>0.8*rab) cc = cc*2.0;      // 若UE与DU夹角小于37°，松弛因子再次增倍
$CC if (ab<0.0) cc = cc*0.5;          // 若UE与DU夹角大于90°，松弛因子减半
$CC if (ab<-0.40*rab) cc = cc*0.5;    // 若UE与DU夹角大于114°，松弛因子再次减半
$CC if (ab<-0.80*rab) cc = cc*0.5;    // 若UE与DU夹角大于143°，松弛因子再次减半
$CC }                                 //
$CC if (cc>1.0) cc = 1.0;             // 控制松弛因子不能大于1
$CC ul = 0.0;
%NOD
%DOF
$CC // === 根据松弛因子(cc)更新迭代步增量 ===
 [ue] = [ue]*cc;
$CC // === 计算本迭代步松弛后的结果 u1 ===
 [u1] = [u1]+[ue];
$CC // === 计算本迭代步松弛后结果 u1 的模平方的和 ul ===
 ul = ul + [u1]*[u1];
%DOF
%NOD
#sum double ul
\$CC WRITE(*,*) 'CC,ERR =',CC,ERR
\$CC WRITE(*,*) 'AB,RAB =',AB,RAB
$CC // ===================================================================
$CC // =    收敛判断                                                     =
$CC // =    err足够小，或者err相对于计算结果的模的平方的和足够小         =
$CC // =    或者迭代步数超出最大迭代步，都会被判断为收敛，停止迭代       =
$CC // =    end为迭代收敛标志变量。                                      =
$CC // ===================================================================
$CC if (err<tolerance || err<tolerance*ul || itn>itnmax) end = 1;
#min int end
$CC if (end==1){                     // 如果收敛
$CC if (time_now<1.5*dt) {               // 如果时间步为第一时间步
$CC // === 总位移取初值：0.0 === 
[gu]=0.0
$CC }
$CC // === 计算当前载荷步总位移 ===
[gu]=[gu]+[u1]
$CC itn=1;                           // 迭代步归1
[du] = 0.0;
$CC } else {                         // 若不收敛
$CC // === 更新当前迭代步增量 ===
[du] = [ue]
$CC itn=itn+1;                       // 更新迭代步
$CC }
$CC // === 将本迭代步最终结果存储到指针数组unod中 === 
WRITE(o,unod) u1,du,gu

@SUBET
 double aa,bb,ab,rab,err,ul;
 static double cc;

END
