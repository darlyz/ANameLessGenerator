\ 非线性双曲型方程算法nnewmarkr.sch(计算位移、速度、加速度，瑞利阻尼)
\ 根据双曲型方程算法文件 newmarkr.sch(瑞利阻尼) 得到的线性方程组：
\  ( [S]*(1+b2*β/(γ*Δt)) +[M]*(1/(γ*Δt*Δt)+b1*β/(γ*Δt)) )[Uˉ] = [Fˉ]
\   +[M][U]*( 1/(γ*Δt*Δt) +b1*β/(γ*Δt)       ) +[S][U]*b2*β/(γ*Δt)
\   +[M][V]*( 1/(γ*Δt)    +b1*(β/γ-1)        ) +[S][V]*b2*(β/γ-1)
\   +[M][A]*( (1/(2*γ)-1) +b1*(β/(2*γ)-1)*Δt ) +[S][A]*b2*(β/(2*γ)-1)*Δt
\ 其中 Uˉ=U(t+Δt)，同理Fˉ。在每一时间步中非线性迭代采用松弛迭代法(见nell.sch)：
\     U_(k+1) = U_(k) + cc*(U_(k+1) - U_(k)), cc∈(0,1] ⑴
\ ------------------------------------------------------------------
DEFI
STIF s
MASS m
DAMP c
LOAD f
TYPE w
MDTY l
INIT 3

COEF u

EQUATION
VECT u1,v1,w1,u,du
\.... 读取解空间中的 u1,v1,w1 作为上一时刻的位移、速度、加速度，u,du 作为上一迭代步位移和增量 ..../
READ(s,unod) u1,v1,w1,u,du
\.................................. 线性方程组左端项(分布矩阵) .................................../
MATRIX = [s]*(1+b2*a1)+[m]*(a0+b1*a1)
\....................................... 线性方程组右端项 ......................................../
FORC = [f]+[m*u1]*(a0+b1*a1)+[m*v1]*(a2+b1*a4)+[m*w1]*(a3+b1*a5) \
    +[s*u1]*a1*b2+[s*v1]*a4*b2+[s*w1]*a5*b2

SOLUTION uu
VECT u,uu,v,w,,u1,v1,w1,du,ue
$cc // ............. 读取上一时刻的位移 u1、速度 v1、加速度w1 ，上一迭代步位移 u 和增量 du .........../
READ(s,unod) u1,v1,w1,u,du
$CC aa = 0.0;
$CC ab = 0.0;
$CC bb = 0.0;
$cc //.................................. 循环所有节点上的所有自由度 ................................../
$cc //...................................... 计算当前增量 UE ........................................./
$cc //............................. 计算当前迭代步增量 UE 的模的平方和 aa............................./
$cc //..................... 计算当前迭代步增量 UE 与上一迭代步增量 DU 内积的和 ab......................./
$cc //............................. 计算上一迭代步增量 DU 的模的平方的和 bb............................./
%NOD
%DOF
        [ue] = [uu]-[u];
        aa = aa+[ue]*[ue];
        ab = ab+[ue]*[du];
        bb = bb+[du]*[du];
%DOF
%NOD
#sum double aa ab bb
$CC err = aa;                         // err 为当前迭代步误差
$CC if (itn == 1) cc = 1.0;           // 迭代第一步取松弛因子为 1
$CC if (itn>1) {                      // 下面每一迭代步都调整松弛因子
$CC rab = sqrt(aa)*sqrt(bb);          // 当前增量UE与上一增量DU模乘积
$CC if (ab>0.5*rab) cc = cc*2.0;      // 若UE与DU夹角余弦值大于0.5，松弛因子增倍
$CC if (ab>0.8*rab) cc = cc*2.0;      // 若UE与DU夹角余弦值大于0.8，松弛因子再次增倍
$CC if (ab>0.0) cc = cc*0.5;          // 若UE与DU夹角余弦值小于0，松弛因子减半
$CC if (ab>-0.40*rab) cc = cc*0.5;    // 若UE与DU夹角余弦值小于-0.4，松弛因子再次减半
$CC if (ab>-0.80*rab) cc = cc*0.5;}   // 若UE与DU夹角余弦值小于-0.8，松弛因子再次减半
$CC if (cc>1.0) cc = 1.0;             // 控制松弛因子不能大于1
$CC ul = 0.0;
$cc //.................................. 循环所有节点上的所有自由度 ................................../
$cc //..................................... 修正当前迭代步位移 ......................................./
$cc //.................................... 计算修正位移的模平方 ....................................../
%NOD
%DOF
        [uu] = [u]+[ue]*cc;
        ul = ul + [u]*[u];
%DOF
%NOD
#sum double ul
$CC //printf("it,itn,cc,err = %d %d %f %f",it,itn,cc,err);
$CC //printf("ab,rab = %f %f",ab,rab);
$CC if (err<tolerance || err<tolerance*ul || itn>itnmax) end = 1;
#min int end
$CC if (end==1){
$CC itn = 1;
$cc //..................................... 若当前时步迭代结束 ......................................./
$cc //...................................... 更新位移解 u=uu ........................................./
$cc //............. 通过 w = (u-u1)/(γ*Δt*Δt)-v1/(γ*Δt)-w1*(1/(2*γ)-1) 计算当前加速度 ................/
$cc //.......................... 通过 v = v1+((1-β)*w+β*w1)*Δt 计算当前速度 ........................../
[u] = [uu];
[w] = ([u]-[u1])*a0-[v1]*a2-[w1]*a3
[v] = [v1]+[w]*a7+[w1]*a6
$CC itn = 1;
$cc //....................... 存储当前时刻位移、速度、加速度和位移增量 u v w ue ....................../
WRITE(s,unod) u,v,w,u,ue
$CC }
$CC else {
$CC itn = itn+1;
$cc //....... 存储未迭代结束的当前时步位移、速度、加速度 u1 v1 w1 和当前迭代步位移、增量 uu ue ......./
WRITE(o,unod) u1,v1,w1,uu,ue
$CC }

@BEGIN
 double o,a0,a1,a2,a3,a4,a5,a6,a7,a8,b1,b2;
        o = 0.5;                    // o := β
        a8 = 0.25*(.5+o)*(.5+o);    // aa:= γ = (1/2+β)*(1/2+β)/4
        a0 = 1./(dt*dt*a8);         // a0 = 1/(γ*Δt*Δt)
        a1 = o/(a8*dt);             // a1 = β/(γ*Δt)
        a2 = 1./(a8*dt);            // a2 = 1/(γ*Δt)
        a3 = 1./(2*a8)-1.;          // a3 = 1/(2*γ)-1
        a4 = o/a8-1.;               // a4 = β/γ-1
        a5 = dt/2*(o/a8-2.);        // a5 = (β/(2*γ)-1)*Δt
        a6 = dt*(1.-o);             // a6 = (1-β)*Δt
        a7 = dt*o;                  // a7 = β*Δt
        b1 = dampalfa;
        b2 = dampbeta;

@SUBET
 double aa,bb,ab,rab,err,ul;
 double static cc;

END
