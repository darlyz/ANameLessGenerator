\ 非线性双曲型方程算法nwave.sch
\ 根据双曲型方程算法wave.sch离散方程：
\          ([M]+[C]*Δt/2+[S]*Δt*Δt/4)[U]
\         =([M]+[C]*Δt/2-[S]*Δt*Δt/4)[ˉU]
\          +[M][ˉV]*Δt +[^F]*Δt*Δt/2
\ 在每一时间步非线性迭代采用松弛迭代法：
\     U_(k+1) = U_(k) + cc*(U_(k+1) - U_(k)), cc∈(0,1] ⑴
\ --------------------------------------------------------------
DEFI
STIF s
MASS m
DAMP c
LOAD f
TYPE w
MDTY l
INIT 2

COEF u

EQUATION
VECT u1,v1,u,du
\.......... 读取解空间中的 u1,v1 作为上一时刻的位移和速度，u,du 作为上一迭代步位移和增量........./
READ(s,unod) u1,v1,u,du
\................................. 线性方程组左端项(分布矩阵) .................................../
MATRIX = [s]*(dt/2)*(dt/2)+[c]*dt/2+[m]
\......................................... 右端矩阵 ............................................./
FORC = [f]*dt*dt/2+[m*u1]+[m*v1]*dt+[c*u1]*dt/2-[s*u1]*dt*dt/4

SOLUTION uu
VECT u,uu,u1,v1,v,ue,du
$cc // ............. 读取上一时刻的位移和速度 u1 v1，上一迭代步位移 u 和增量 du .........../
READ(s,unod) u1,v1,u,du
$CC aa = 0.0;
$CC ab = 0.0;
$CC bb = 0.0;
$cc //............................... 循环所有节点上的所有自由度 ........................../
$cc //................................... 计算当前增量 UE ................................./
$cc //.......................... 计算当前迭代步增量 UE 的模的平方和 aa...................../
$cc //.................. 计算当前迭代步增量 UE 与上一迭代步增量 DU 内积的和 ab.............../
$cc //.......................... 计算上一迭代步增量 DU 的模的平方的和 bb...................../
%NOD
%DOF
        [ue] = [uu]-[u];
        aa = aa+[ue]*[ue];
        ab = ab+[ue]*[du];
        bb = bb+[du]*[du];
%DOF
%NOD
#sum double aa ab bb
$CC err = aa;                        // err 为当前迭代步误差
$CC if (itn == 1) cc = 1.0;          // 迭代第一步取松弛因子为 1
$CC if (itn>1) {                     // 下面每一迭代步都调整松弛因子
$CC rab = sqrt(aa)*sqrt(bb);         // 当前增量UE与上一增量DU模乘积
$CC if (ab>0.5*rab) cc = cc*2.0;     // 若UE与DU夹角余弦值大于0.5，松弛因子增倍
$CC if (ab>0.8*rab) cc = cc*2.0;     // 若UE与DU夹角余弦值大于0.8，松弛因子再次增倍
$CC if (ab<0.0) cc = cc*0.5;         // 若UE与DU夹角余弦值小于0，松弛因子减半
$CC if (ab<-0.40*rab) cc = cc*0.5;   // 若UE与DU夹角余弦值小于-0.4，松弛因子再次减半
$CC if (ab<-0.80*rab) cc = cc*0.5;   // 若UE与DU夹角余弦值小于-0.8，松弛因子再次减半
$CC }                                //
$CC if (cc>1.0) cc = 1.0;            // 控制松弛因子不能大于1
$CC ul = 0.0;
$cc //............................ 循环所有节点上的所有自由度 ............................/
$cc //............................... 修正当前迭代步位移 ................................./
$cc //.............................. 计算修正位移的模平方 ................................/
%NOD
%DOF
       [u] = [u]+[ue]*cc;
       ul = ul + [u]*[u];
%DOF
%NOD
#sum double ul
$CC if (err<tolerance || err<tolerance*ul || itn>itnmax) end = 1;
#min int end
$CC if (end==1){
$CC itn = 1;
$cc //............................... 若当前时步迭代结束 ................................./
$cc //..................... 通过 v1 = 2(u-u1)/Δt-v1 计算当前速度 ........................./
$cc //................................ 更新位移解 u1=u .................................../
[v1] = [u]/dt*2-[u1]/dt*2-[v1]
[u1] = [u]
$CC }
$CC else {
$CC itn = itn+1;
$CC }
$cc //............ 存储当前时步的位移、速度 u1 v1 和当前迭代步位移、增量 u ue ............/
WRITE(o,unod) u1,v1,u,ue

@SUBET
 double aa,bb,ab,rab,err,ul;
 double static cc;

END
